\section{Erzeugen von Kodierer, Permutationsvektor und Punktierungsmatrix}
\label{sec:example_createHelpers}
Zuerst werden Hilfsvariablen erzeugt, die für die folgende Kodierungs- und Dekodierungsverfahren benötigt werden. Diese Variablen müssen nicht unbedingt mitgegebenen werden, dann werden die Standard-Werte verwendet. Das bedeutet, dass falls keine Punktierungsmatrix übergeben wird, der Standard-Wert \emph{NULL} ist und darum nicht punktiert wird. Ebenfalls wird nicht permutiert, wenn kein Permutationsvektor als Argument übergeben wird. Es wird zwar ein Permutationsvektor benötigt, damit die Interleaver richtig arbeiten können, jedoch wird ein Vektor vom Typ \emph{PRIMITIVE} verwendet, dieser allerdings ändert die Reihenfolge der Bits nicht (root=0). Beim Kodierer verhält es sich ähnlich, jedoch wird hier ein vordefinierter Standard-Faltungskodierer verwendet (\emph{ConvGenerateRscEncoder(2,2,c(5,7))}), dieser wird in allen Turbo-Kode-Funktionen benützt, falls kein eigener Kodierer übergeben wird.

\begin{lstlisting}[caption=Erzeugung von Kodierer und Punktierungsmatrix, label={lst:createHelpersCoderPunctuation}]
input <- c(1,0,1,1,0)

coder <- ConvGenerateEncoder(2, 2, c(4,5))

punctuation.matrix <- TurboGetPunctuationMatrix(c(1,1,0,0,1,1))
\end{lstlisting}

Wie im Listing \ref{lst:createHelpersCoderPunctuation} zu sehen ist, wird als allererstes eine zu kodierende Nachricht erzeugt, die dann benötigt wird, die dann benötigt wird um eine Punktierungsmatrix zu bekommen. Anschließend wird ein nicht rekursiver Faltungskodierer, mit der Funktion vom Faltungskode-Teil des Packetes \cite{nocker}, erzeugt. Dabei wurde ein Kodierer mit 2 Registern und 2 Ausgängen gewählt. Wichtig ist, dass der erste Ausgang vom Eingang durchgeschalten wird damit es ein systematischer Kodierer ist. Das wird erreicht, indem das 1.Generatorpolynom mit $2^M = 2^2 = 4$ deklariert wird.

\begin{lstlisting}[caption=Erzeugung von verschiedenen Permutationsvektoren, label={lst:createHelpersPermutation}]
permutation.vector.random <- TurboGetPermutation(length(input), coder, "RANDOM")
permutation.vector.primitve <- TurboGetPermutation(length(input), coder, "PRIMITIVE", list(root=3))

input2 <- c(1,0,1,1,0,1)
permutation.vector.cyclic <- TurboGetPermutation(length(input2), coder, "CYCLIC", list(cols=4, rows=2, distance=2))
permutation.vector.block <- TurboGetPermutation(length(input2), coder, "BLOCK", list(cols=4, rows=2))
permutation.vector.helical <- TurboGetPermutation(length(input2), coder, "HELICAL", list(cols=4, rows=2))
permutation.vector.diagonal <- TurboGetPermutation(length(input2), coder, "DIAGONAL", list(cols=4, rows=2), TRUE)
[1] "Initial-Matrix"
     [,1] [,2] [,3] [,4]
[1,]    0    1    2    3
[2,]    4    5    6    7
[1] "Interleaver-Vector:  DIAGONAL"
[1] 0 5 1 6 2 7 3 4
\end{lstlisting}

Als nächstes benötigt der Benutzer noch einen Permutationsvektor, dieser wird im Listing \ref{lst:createHelpersPermutation} erzeugt. Dabei wird jeder Typ einmal verwendet. Bei den ersten beiden werden die Eingangsbits von Listing \ref{lst:createHelpersCoderPunctuation} benützt. Da bei den restlichen Typen eine Matrix benötigt wird, muss die Länge der Eingangsbits genau in einer Matrix Platz finden, deshalb wurde ein 2. Eingangsvektor definiert, der allerdings nur als Demonstration für die anderen Permutationstypen dienen sollte, dieser wird in den weiteren Beispielen nicht weiter verwendet. Es kann auch das Visualisierungsflag auf \emph{TRUE} gesetzt werden, dann wird die Ausgangsmatrix und der resultierende Permutationsvektor dargestellt. Dies wurde bei dem letzten Beispiel mit dem Typ \emph{DIAGONAL} demonstrativ verwendet.

\section{Kodieren und Dekodieren ohne Punktierung}
\label{sec:example_withoutPunctuation}
Nachdem alle benötigten Variablen gesetzt wurden kann nun die Kodierung und Dekodierung vorgenommen werden. Dabei wird zuerst ohne Punktierung gearbeitet, jedoch alle anderen zuvor definierten Variablen verwendet.

\begin{lstlisting}[caption=Kodierung und Dekodierung ohne Punktierung, label={lst:encodeDecodeWithoutPunctuation}]
encoded <- TurboEncode(input, permutation.vector.random, coder, 2)
encoded
[1] -1 -1 -1  1  1  1 -1  1  1 -1 -1  1  1 -1 -1  1 -1 -1  1  1  1

encoded.noisy <- ApplyNoise(encoded, 0.1)
round(encoded.noisy, 2)
[1] -2.41 -2.36 -0.26  1.06  1.37  0.22  1.13  0.93  0.33 -1.15 -1.18  0.59
[13]  1.32 -0.31 -1.37 -0.01 -1.42 -1.62  2.18  2.29  0.93

decoded <- TurboDecode(encoded.noisy, permutation.vector.random, 5, coder, 2)
decoded
$output.soft
[1]  -1.394185  1.394185  2.775904 -1.394185  2.775904

$output.hard
[1] 1 0 1 1 0
\end{lstlisting}

Der gesamte Vorgang lässt sich in wenigen Zeilen erledigen, wie in Listing \ref{lst:encodeDecodeWithoutPunctuation} zu sehen ist. Zuerst werden einfach die zuvor definierten Variablen der Kodierungsfunktion mitgegeben, als letzter Parameter wird noch der Index des zu verwendeten Ausgangs des Kodierers angegeben (2 in diesem Fall). Danach erhält man das kodierte Signal mit dem Signalpegel 1 und -1. Dieses Signal wird dann einem Signal/Rausch-Verhältnis von 0.1dB  verrauscht und anschließend ausgegeben, damit man den Unterschied zwischen Originalsignal und Verrauschtem sieht. Dabei werden nur 2 Nachkommastellen ausgegeben, um die Länge der Ausgabe zu kürzen. 

Nachdem das Signal kodiert und übertragen wurde, kann der Empfänger es nun wieder dekodieren. Dabei schickt er das empfangene Signal in die Dekodierungsfunktion, als Iterationsanzahl wird 5 gewählt. Das Ergebnis ist dann eine Liste mit den Soft- und Hard-Werten. Dabei ist zu erkennen, dass positive Soft-Werte auf eine 0 und negative auf eine 1 abgebildet werden. Bei diesem Beispiel ist schön zu sehen, dass auch ein ziemlich verrauschtes Signal vom Turbo-Dekodierer wieder hergestellt werden kann.
\section{Kodieren und Dekodieren mit Punktierung}
\label{sec:example_withPunctuation}

\section{Simulationen}
\label{sec:example_simulations}

\subsection{Turbo-Kode-Simulation}

\subsection{Kanalkodierungs-Simulation}

\subsection{Vergleich mehrerer Simulationen}