% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/convolution.R
\name{ConvGenerateEncoder}
\alias{ConvGenerateEncoder}
\title{Generate convolutional encoder.}
\usage{
ConvGenerateEncoder(N, M, generators)
}
\arguments{
\item{N}{Numer ob output symbols per input symbol.}

\item{M}{Memory length of the encoder.}

\item{generators}{Vector of N octal generator polynoms
(one for each output symbol).}
}
\value{
A convolutional encoder represented as a list containing:
    N, M, vector of generator polynoms,
    4 matrices: nextState, previousState, output and termination, rsc (flag),
    termination vector
}
\description{
Generates a convolutional encoder for nonrecursive convolutional codes.
}
\details{
N is an integer and gives the number of output bits per input bit.
    N has to be at least two. M is an integer and gives the memory length
    of the encoder (number of shift register elements in the circuit). M
    has to be at least one. M also defines the constraint length which is
    M+1.
    The generator polynoms define how the output bits are computed for each
    of the N output signals. The polynoms are octal numbers. For example
    given a M = 2 encoder with a generator polynom of 5 for a certain output.
    Octal 5 means binary 101. The MSB handles the input signal, the LSB
    handles the output of the last memory element (last shift register
    element). Therefore octal 5 means the output symbol is computed as
    the xor combination of the input symbol and the last memory element's
    output.
}
\examples{
ConvGenerateEncoder(2,2,c(7,5))
}
\author{
Martin Nocker
}

