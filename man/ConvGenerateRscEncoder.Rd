% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/convolution.R
\name{ConvGenerateRscEncoder}
\alias{ConvGenerateRscEncoder}
\title{Generate rsc encoder.}
\usage{
ConvGenerateRscEncoder(N, M, generators)
}
\arguments{
\item{N}{Numer ob output symbols per input symbol.}

\item{M}{Memory length of the encoder.}

\item{generators}{Vector of generator polynoms
(one for each non-systematic output symbol and one for the recursion).}
}
\value{
A convolutional encoder represented as a list containing:
    N, M, vector of generator polynoms,
    3 matrices: nextState, previousState and output, rsc (flag),
    termination vector
}
\description{
Generates a recursive systematic convolutional (rsc) encoder.
}
\details{
N is an integer and gives the number of output bits per input bit.
    N has to be at least two. M is an integer and gives the memory length
    of the encoder (number of shift register elements in the circuit). M
    has to be at least one.
    The generator polynoms define how the output bits are computed for each
    of the N output signals. The polynoms are octal numbers. See details of
    \code{\link{ConvGenerateEncoder}} for an example.
    An rsc encoder has exactly one fixed systematic output signal.
    The generator polynom for the systematic output doesn't have to be
    passed as an argument. So the generators argument contains all polynoms
    for non-systematic outputs and at the last position the recursion
    polynom. The MSB of the recursion polynom handles the input signal,
    the other bits handle the memory outputs. The MSB of the output polynoms
    handle the recursion output(!), not the original input signal. The other
    bits also handle the memory outputs. See 'The art of error correcting
    coding' (p.92f) for a detailed definition and an example.
}
\examples{
# standard rsc encoder with code-rate = 0.5
ConvGenerateRscEncoder(2,2,c(5,7))
}
\author{
Martin Nocker
}

